**复杂data的处理方式**



我们知道，在模板中可以直接通过**插值语法**显示一些**data中的数据**。 

n 但是在某些情况，我们可能需要对**数据进行一些转化后**再显示，或者需要**将多个数据结合起来**进行显示；

p比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示；

p在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算； 

p在模板中放入太多的逻辑会让模板过重和难以维护； 

p并且如果多个地方都使用到，那么会有大量重复的代码；

n 我们有没有什么方法可以将逻辑抽离出去呢？

p可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中；

p但是，这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用； 

p另外一种方式就是使用计算属性computed；



对于任何包含响应式数据的复杂逻辑，你都应该使用**计算属性**； 

p计算属性将被混入到组件实例中。所有 getter 和 setter 的 this 上下文自动地绑定为组件实例；

n 计算属性的用法：

p**选项：**computed

p**类型：**{ [key: string]: Function | { get: Function, set: Function } }

在上面的实现思路中，我们会发现计算属性和methods的实现看起来是差别是不大的，而且我们多次提到计算属性有缓存的。 